package guardian-one:attacks@0.1.0;

/// ---------------------------------------------------
/// 1. COMMON TYPES
/// ---------------------------------------------------

interface common-types {
    record telemetry-packet {
        timestamp: u64,
        value: f64,
        status: u8
    }
}

/// ---------------------------------------------------
/// 2. CAPABILITY INTERFACES
/// ---------------------------------------------------

/// The "Honey Pot" - Capabilities the attacker WANTS but shouldn't have.
/// In the demo, you import these so the code *can* try to call them,
/// but the Host strictly returns errors.
interface attack-surface {
    // Attempt to hijack the thread or exhaust memory
    malloc-large: func(size: u64) -> result<u64, string>;
    
    // Attempt to exfiltrate data
    open-socket: func(addr: string) -> result<u32, string>;
    
    // Attempt to read unauthorized files
    read-file: func(path: string) -> result<list<u8>, string>;
}

/// The actual job requirements - what sensors legitimately need.
interface sensor-capabilities {
    read-hardware-register: func(reg-id: u32) -> f64;
    log-debug: func(msg: string);
}

/// ---------------------------------------------------
/// 3. WORLDS (The Architecture)
/// ---------------------------------------------------

/// THE WORKER (Untrusted)
/// This is the component you instantiate 3 times.
/// It has NO knowledge of TMR, voting, or other workers.
world sensor-node {
    // Valid imports (granted capabilities)
    import sensor-capabilities;
    
    // Invalid imports (for demo - host returns errors)
    import attack-surface;
    
    // The only way the host talks to it
    export process-tick: func() -> common-types.telemetry-packet;
}

/// THE SUPERVISOR (Trusted)
/// Manages the lifecycle. Can be the Host (Rust/JS) 
/// or a privileged "Control Plane" component.
world system-supervisor {
    // The supervisor needs TMR logic to make decisions
    import tmr-logic;
}

interface tmr-logic {
    use common-types.{telemetry-packet};
    
    // Takes 3 packets, returns the consensus packet
    consensus-2oo3: func(
        a: telemetry-packet, 
        b: telemetry-packet, 
        c: telemetry-packet
    ) -> result<telemetry-packet, string>;
    
    // If a node traps/fails, the supervisor calls this
    trigger-hot-swap: func(node-index: u8);
}
